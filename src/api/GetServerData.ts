//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {ClientBase} from "./client-base";
import {ServerDetailsDto} from "../models/ServerDetailsDto";
import {Relationship} from "../models/Relationship";
import {PrivateChat} from "../models/PrivateChat";
import {Message} from "../models/Message";
import {InvitationDetails} from "../models/InvitationDetails";
import {GroupChat} from "../models/GroupChat";
import {UserDetails} from "../models/UserDetails";
import {Attachment} from "../models/Attachment";
import {EventP} from "../Events";
import ChatWebsocketService from "../ChatWebSocketService";

export class GetServerData extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private _websocketService: ChatWebsocketService;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this._websocketService = new ChatWebsocketService();
        window.addEventListener("beforeunload", (e) => {
            this._websocketService.disconnect();
        });
    }
    get websocket() : ChatWebsocketService
    {
        return this._websocketService
    }

    /**
     * Create a text channel attached to a server
     * @param body (optional) ```
     title: string // up to 100 characters
     serverId: string // represents ObjectId
     ```
     * @return Created
     */
    createChannel(body: CreateChannelRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Channels/CreateChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChannel(_response);
        });
    }

    protected processCreateChannel(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
                return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * A request to set a new title for a provided channel
     * @param body (optional) ```
     chatId: string // represents ObjectId
     newTitle: string // up to 100 characters
     ```
     * @return Ok. Operation is successful
     */
    renameChannel(body: RenameChannelRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Channels/RenameChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameChannel(_response);
        });
    }

    protected processRenameChannel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested channel is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * A request to remove the provided channel by its id
     * @param body (optional) ```
     chatId: string // represents ObjectId of a channel
     ```
     * @return Ok. Operation is successful
     */
    removeChannel(body: RemoveChannelRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Channels/RemoveChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveChannel(_response);
        });
    }

    protected processRemoveChannel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException("Bad Request. The requested channel is not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets Invitation details
     * @param id Id of the invitation to get details from
     * @return Ok. Invitation details in JSON
     */
    invitation(id: string): Promise<InvitationDetails> {
        let url_ = this.baseUrl + "/api/Invitations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvitation(_response);
        });
    }

    protected processInvitation(response: Response): Promise<InvitationDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InvitationDetails;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("BadRequest. The invitation is expired, not available or incorrect", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvitationDetails>(null as any);
    }

    /**
     * Create an invitation as a link
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to invite to
     includeUser: bool // Show the user that makes this invitation
     expireTime?: Date // Define when the invitation will be expired
     ```
     * @return Success
     */
    invite(body: CreateInvitationRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Invitations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created. InvitationLink", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Gets a media by it's id
     * @param id Unique id string that represents ObjectId
     * @param details (optional) <br>By default false.
     <br>If set to true, the result would be Json detailed information of the media
     <br>If set to false, the result would be media content (data in binary) showed accordingly to it's content type
     * @return <br>Ok.
     <br>By default returns the media content in binary and show it accordingly to it's content type
     <br>If the details param is set to true, returns json with the detailed information about the media
     */
    indexGET(id: string, details: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (details === null)
            throw new Error("The parameter 'details' cannot be null.");
        else if (details !== undefined)
            url_ += "details=" + encodeURIComponent("" + details) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndexGET(_response);
        });
    }

    protected processIndexGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested media is not found", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Uploads the media file to the database
     * @param contentType (optional)
     * @param contentDisposition (optional)
     * @param headers (optional)
     * @param length (optional)
     * @param name (optional)
     * @param fileName (optional)
     * @return Created. Operation is successful
     */
    indexPOST(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndexPOST(_response);
        });
    }

    protected processIndexPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Loads a page of Messages from the given chat to show them in client app. The size of a page defined as a constant (see !:GetMessagesRequestHandler._pageSize)
     * @param chatId (optional) string ObjectId representation of the chat to get pinned messages from
     * @param messagesCount (optional) The amount of messages that already loaded to skip them. Set 0 to load last messages
     * @return Ok. A list of messages to show
     */
    getMessages(chatId: string | undefined, messagesCount: number | undefined): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/Messages/GetMessages?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        if (messagesCount === null)
            throw new Error("The parameter 'messagesCount' cannot be null.");
        else if (messagesCount !== undefined)
            url_ += "messagesCount=" + encodeURIComponent("" + messagesCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<Message[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Message[];
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message[]>(null as any);
    }

    /**
     * Loads all of the Messages that are pinned in the given chat
     * @param chatId (optional) string ObjectId representation of the chat to get pinned messages from
     * @return Ok. A list of pinned messages in the chat
     */
    getPinnedMessages(chatId: string | undefined): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/Messages/GetPinnedMessages?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPinnedMessages(_response);
        });
    }

    protected processGetPinnedMessages(response: Response): Promise<Message[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Message[];
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message[]>(null as any);
    }

    /**
     * Adds message to the given chat and notify other members about it
     * @param body (optional) ```
     text: string // Up to 2000 characters
     chatId: string // represents ObjectId of the chat to send the message to
     attachments: Attachment[] // Attachments that user includes to the message
     ```
     * @return No Content. Operation is successful
     */
    addMessage(body: AddMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/AddMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddMessage(_response);
        });
    }

    protected processAddMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds reaction to the message
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to add reaction to
     emoji: string // represents emoji name in colon brackets (:smile:)
     ```
     * @return No Content. Operation is successful
     */
    addReaction(body: AddReactionRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/AddReaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddReaction(_response);
        });
    }

    protected processAddReaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * A request to change the given message text
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to edit
     newText: string // provided text to change the previous one
     ```
     * @return No Content. Operation is successful
     */
    editMessage(body: EditMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/EditMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditMessage(_response);
        });
    }

    protected processEditMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be the owner of the message", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Pins the selected message to the given chat
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to pin
     ```
     * @return No Content. Operation is successful
     */
    pinMessage(body: PinMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/PinMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPinMessage(_response);
        });
    }

    protected processPinMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove all reactions from the given message.
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to remove reactions from
     ```
     * @return No Content. Operation is successful
     */
    removeAllReactions(body: RemoveAllReactionsRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/RemoveAllReactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAllReactions(_response);
        });
    }

    protected processRemoveAllReactions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove a selected attachment from the given message
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to remove the attachment from
     attachmentIndex: int // the index of the attachment to remove
     ```
     * @return No Content. Operation is successful
     */
    removeAttachment(body: RemoveAttachmentRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/RemoveAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAttachment(_response);
        });
    }

    protected processRemoveAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message or attachment is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must to be the owner of the message", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes the given message with it's attachments and reactions
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to remove
     ```
     * @return No Content. Operation is successful
     */
    removeMessage(body: RemoveMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/RemoveMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveMessage(_response);
        });
    }

    protected processRemoveMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove the given reaction you have added
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to remove
     reactionIndex: string // the index of the reaction to remove
     ```
     * @return No Content. Operation is successful
     */
    removeReaction(body: RemoveReactionRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/RemoveReaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveReaction(_response);
        });
    }

    protected processRemoveReaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message or reaction is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must to be the owner of the reaction", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Unpin previously pinned message
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to remove
     ```
     * @return No Content. Operation is successful
     */
    unpinMessage(body: UnpinMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/UnpinMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnpinMessage(_response);
        });
    }

    protected processUnpinMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets all Private Chats the currently authorized user are member of
     * @return Ok. List of the private chat look ups
     */
    getAllPrivateChats(): Promise<PrivateChat[]> {
        let url_ = this.baseUrl + "/api/PrivateChats/GetAllPrivateChats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPrivateChats(_response);
        });
    }

    protected processGetAllPrivateChats(response: Response): Promise<PrivateChat[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrivateChat[];
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivateChat[]>(null as any);
    }

    /**
     * Get details about the given group chat. The details include Title, Image, OwnerId and Users
     * @param chatId (optional) Chat Id to get detailed information from
     * @return Ok. Json group chat object
     */
    getGroupChatDetails(chatId: string | undefined): Promise<GroupChat> {
        let url_ = this.baseUrl + "/api/PrivateChats/GetGroupChatDetails?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupChatDetails(_response);
        });
    }

    protected processGetGroupChatDetails(response: Response): Promise<GroupChat> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GroupChat;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupChat>(null as any);
    }

    /**
     * Creates new group chat
     * @param body (optional) ```
     title: string // up to 100 characters
     image?: string // URL to the image media file
     usersId: number[] // users that are members of the chat from the beginning
     ```
     * @return Created. String representation of an ObjectId of a newly created group chat
     */
    createGroupChat(body: CreateGroupChatRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/PrivateChats/CreateGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGroupChat(_response);
        });
    }

    protected processCreateGroupChat(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText;
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Adds the given user to the group chat as a new member
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to add new member to
     newMemberId: int // Id of the user to add
     ```
     * @return No Content. Operation is successful
     */
    addMemberToGroupChat(body: AddMemberToGroupChatRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/AddMemberToGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddMemberToGroupChat(_response);
        });
    }

    protected processAddMemberToGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or member is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes image of the given group chat
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to change image
     newImage: string // URL to the image media file
     ```
     * @return No Content. Operation is successful
     */
    changeGroupChatImage(body: ChangeGroupChatImageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/ChangeGroupChatImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeGroupChatImage(_response);
        });
    }

    protected processChangeGroupChatImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the title of the given group chat
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to rename
     newTitle: string // up to 100 characters
     ```
     * @return No Content. Operation is successful
     */
    renameGroupChat(body: RenameGroupChatRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/RenameGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameGroupChat(_response);
        });
    }

    protected processRenameGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove the currently authorized user from the group chat
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to leave from
     silent: boolean // by default false; if true, the other chat members will not be notified
     ```
     * @return No Content. Operation is successful
     */
    leaveFromGroupChat(body: LeaveFromGroupChatRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/LeaveFromGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveFromGroupChat(_response);
        });
    }

    protected processLeaveFromGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Transfer owner rights of the group chat to another member of the chat
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to transfer owner of
     memberId: int // id of the user to transfer rights to
     ```
     * @return No Content. Operation is successful
     */
    makeGroupChatOwner(body: MakeGroupChatOwnerRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/MakeGroupChatOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMakeGroupChatOwner(_response);
        });
    }

    protected processMakeGroupChatOwner(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes the given user from the chat members list
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to remove new member from
     memberId: int // Id of the user to remove
     silent: boolean // by default false; if true, the other chat members will not be notified
     ```
     * @return No Content. Operation is successful
     */
    removeGroupChatMember(body: RemoveGroupChatMemberRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PrivateChats/RemoveGroupChatMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveGroupChatMember(_response);
        });
    }

    protected processRemoveGroupChatMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Joins to the server via invitation
     * @param id Id of the invitation to join to the server
     * @return NoContent. Successful operation
     */
    joinServer(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/JoinServer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            "Authorization": "Bearer " + localStorage.getItem("token")}
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinServer(_response);
        });
    }

    protected processJoinServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The invitation is expired, not available or incorrect", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Leave the given server
     * @param id Id of the server to leave from
     * @return NoContent. Successful operation
     */
    leaveServer(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/LeaveServer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            "Authorization": "Bearer " + localStorage.getItem("token")}
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveServer(_response);
        });
    }

    protected processLeaveServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The server is not found", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets all Servers the currently authorized user are member of
     * @return Ok. List of the server look ups
     */
    getServers(): Promise<GetServerLookupDto[]> {
        let url_ = this.baseUrl + "/api/Servers/GetServers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServers(_response);
        });
    }

    protected processGetServers(response: Response): Promise<GetServerLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetServerLookupDto[];
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetServerLookupDto[]>(null as any);
    }

    /**
     * Gets the detailed information about the given server
     * @param serverId (optional) string ObjectId representation of a server to get details of
     * @return Ok. Server details object in JSON
     */
    getServerDetails(serverId: string | undefined): Promise<ServerDetailsDto> {
        let url_ = this.baseUrl + "/api/Servers/GetServerDetails?";
        if (serverId === null)
            throw new Error("The parameter 'serverId' cannot be null.");
        else if (serverId !== undefined)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerDetails(_response);
        });
    }

    protected processGetServerDetails(response: Response): Promise<ServerDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServerDetailsDto;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested server is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerDetailsDto>(null as any);
    }

    /**
     * Creates new server
     * @param body (optional) ```
     title: string // up to 100 characters
     image?: string // URL to the image media file
     ```
     * @return Created. String ObjectId representation of newly created Server
     */
    createServer(body: CreateServerRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Servers/CreateServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServer(_response);
        });
    }

    protected processCreateServer(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Changes the given server's title or image
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to edit
     title?: string // up to 100 characters
     image?: string // URL to the image media file
     ```
     * @return No Content. Operation is successful
     */
    updateServer(body: UpdateServerRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/UpdateServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateServer(_response);
        });
    }

    protected processUpdateServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequestResult;
                return throwException("Bad Request. The requested server is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnauthorizedResult;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ForbidResult;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes the server
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server
     ```
     * @return No Content. Operation is successful
     */
    deleteServer(body: DeleteServerRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/DeleteServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServer(_response);
        });
    }

    protected processDeleteServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server users list. The User can come back if would have an invitation
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to kick user from
     userId: int // id of the user to kick from server
     ```
     * @return No Content. Operation is successful
     */
    kickUser(body: KickUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/KickUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKickUser(_response);
        });
    }

    protected processKickUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server users list and put him in a black list.
     The User can't come back even if it would have an invitation
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to ban user from
     userId: int // id of the user to ban from server
     ```
     * @return No Content. Operation is successful
     */
    banUser(body: BanUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/BanUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanUser(_response);
        });
    }

    protected processBanUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server's black list. Now the user could return if it would have an invitation
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to unban user from
     userId: int // id of the user to unban
     ```
     * @return No Content. Operation is successful
     */
    unbanUser(body: UnbanUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/UnbanUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnbanUser(_response);
        });
    }

    protected processUnbanUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the Display name of the server profile
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to unban user from
     newDisplayName: string
     userId: int // id of the user to change the
     ```
     * @return No Content. Operation is successful
     */
    changeServerProfileDisplayName(body: ChangeServerProfileDisplayNameRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/ChangeServerProfileDisplayName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeServerProfileDisplayName(_response);
        });
    }

    protected processChangeServerProfileDisplayName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. TYour request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the set of roles of the give user
     * @param body (optional) ```
     serverId: string // represents ObjectId of the server to unban user from
     roles: number[] // the roles IDs
     userId: int // id of the user to change the
     ```
     * @return No Content. Operation is successful
     */
    changeServerProfileRoles(body: ChangeServerProfileRolesRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Servers/ChangeServerProfileRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeServerProfileRoles(_response);
        });
    }

    protected processChangeServerProfileRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get information for testing authorization.
     * @return Returns the test information for authorization.
     */
    get(): Promise<TestDto> {
        let url_ = this.baseUrl + "/api/TestAuth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("The client must authenticate itself to get the requested response. The client is not authorized to access the resource.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestDto>(null as any);
    }

    /**
     * Gets detailed information about the provided user, including it's ServerProfile if ServerId is provided
     * @param userId (optional) The id (int) of the user to get information from
     * @param serverId (optional) string ObjectId represents of server. Can be provided if ServerProfile is required. Null by default
     * @return Ok. User details object in JSON
     */
    getUser(userId: string | undefined, serverId: string | undefined): Promise<UserDetails> {
        let url_ = this.baseUrl + "/api/Users/GetUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (serverId === null)
            throw new Error("The parameter 'serverId' cannot be null.");
        else if (serverId !== undefined)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDetails;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetails>(null as any);
    }

    /**
     * Gets detailed information about the currently authorized user
     * @return Ok. User details object in JSON
     */
    getCurrentUser(): Promise<UserDetails> {
        let url_ = this.baseUrl + "/api/Users/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDetails;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetails>(null as any);
    }

    /**
     * Sends message to user you don't have chat with.
     This request will create new chat and set relationship Application.Models.RelationshipType.Acquaintance to both
     * @param body (optional)
     * @return No Content
     */
    sendMessageToUser(body: SendMessageToUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/SendMessageToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessageToUser(_response);
        });
    }

    protected processSendMessageToUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getRelationships(): Promise<Relationship[]> {
        let url_ = this.baseUrl + "/api/Users/GetRelationships";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelationships(_response);
        });
    }

    protected processGetRelationships(response: Response): Promise<Relationship[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Relationship[];
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Relationship[]>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    sendFriendRequest(body: FriendRequestRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/SendFriendRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendFriendRequest(_response);
        });
    }

    protected processSendFriendRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    acceptFriendRequest(body: AcceptFriendRequestRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/AcceptFriendRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptFriendRequest(_response);
        });
    }

    protected processAcceptFriendRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface AcceptFriendRequestRequest {
    /** The unique identifier of the user who sent the friend request to accept it */
    userId?: string;
}

export interface AddMemberToGroupChatRequest {
    /** The unique identifier of the group chat to add a new member to */
    chatId: string;
    /** The unique identifier of the new member to be added */
    newMemberId: string;
}

export interface AddMessageRequest {
    /** Text of the message. Can include links */
    text?: string | undefined;
    /** Id of the chat to send message to */
    chatId: string;
    /** List of URL attachments that are not included in the message text */
    attachments?: Attachment[] | undefined;
}

export interface AddReactionRequest {
    /** Id of the message to add a reaction to */
    messageId: string;
    /** Emoji code */
    emoji: string;
}

export interface AuthenticationProperties {
    items?: { [key: string]: string; } | undefined;
}

export interface BadRequestResult {
    statusCode?: number;
}

export interface BanUserRequest {
    serverId: string;
    userId: string;
}

export interface ChangeGroupChatImageRequest {
    /** The unique identifier of the group chat to change the image for */
    chatId: string;
    /** The URL of the new image for the group chat */
    newImage: string;
}

export interface ChangeServerProfileDisplayNameRequest {
    serverId: string;
    newDisplayName: string;
    userId: string;
}

export interface ChangeServerProfileRolesRequest {
    serverId?: string | undefined;
    roles?: string[] | undefined;
    userId?: string;
}

export interface CreateChannelRequest {
    /** Name of the channel */
    title: string;
    /** Id of the server where chat will be created */
    serverId: string;
}

export interface CreateGroupChatRequest {
    /** The title of the group chat. */
    title: string | undefined;
    /** The URL of the image for the group chat. (Optional) */
    image?: string | undefined;
    /** The list of unique identifiers of users to be added to the group chat. */
    usersId: string[];
}

export interface CreateInvitationRequest {
    /** The unique identifier of the server to create an invitation for. */
    serverId?: string | undefined;
    /** Indicates whether to include user information in the invitation. */
    includeUser?: boolean;
    /** The expiration time of the invitation. (Optional) */
    expireTime?: Date | undefined;
}

export interface CreateServerRequest {
    /** New Server's name */
    title: string;
    /** Server image url */
    image?: string | undefined;
}

export interface DeleteServerRequest {
    /** Id of the server to delete */
    serverId: string;
}

export interface EditMessageRequest {
    /** Id of the message to edit */
    messageId: string;
    /** New message text. May include links */
    newText: string;
}

export interface ForbidResult {
    authenticationSchemes?: string[] | undefined;
    properties?: AuthenticationProperties;
}

export interface FriendRequestRequest {
    /** The unique identifier of the user to send a friend request to. */
    userName: string;
}

export interface GetServerLookupDto {
    /** The unique identifier of the server */
    id?: string | undefined;
    /** Server's name */
    title?: string | undefined;
    /** Avatar Url of the Server */
    image?: string | undefined;
}

export interface KickUserRequest {
    serverId: string;
    userId: string;
}

export interface LeaveFromGroupChatRequest {
    /** The unique identifier of the group chat to leave from. */
    chatId: string;
    /** Indicates whether to leave the group chat silently without sending notifications. (Optional, default is false) */
    silent?: boolean;
}

export interface MakeGroupChatOwnerRequest {
    /** The unique identifier of the group chat to change an owner in. */
    chatId: string;
    /** The unique identifier of the member to be made the owner. */
    memberId: string;
}

export interface PinMessageRequest {
    /** Id of the message to be pinned */
    messageId: string;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum RelationshipType {
    Acquaintance = 0,
    Friend = 1,
    Pending = 2,
    Waiting = 3,
    Blocked = 4,
}

export interface RemoveAllReactionsRequest {
    /** Id of the message for which all reactions should be removed */
    messageId: string;
}

export interface RemoveAttachmentRequest {
    /** Id of the message to which the attachment is attached */
    messageId: string;
    /** Index of the attachment in the message's attachments collection */
    attachmentIndex: number;
}

export interface RemoveChannelRequest {
    /** Id of the channel to be removed */
    chatId: string;
}

export interface RemoveGroupChatMemberRequest {
    /** The unique identifier of the group chat to remove a member from. */
    chatId: string;
    /** The unique identifier of the member to be removed from the group chat. */
    memberId: string;
    /** Indicates whether to remove the member silently without sending notifications. (Optional, default is false) */
    silent?: boolean;
}

export interface RemoveMessageRequest {
    /** Id of the message to remove */
    messageId: string;
}

export interface RemoveReactionRequest {
    /** Id of the message to which the reaction is attached */
    messageId: string;
    /** Index of the reaction in the message's reactions collection */
    reactionIndex: number;
}

export interface RenameChannelRequest {
    /** Id of the channel to be renamed */
    chatId: string;
    /** New name of the channel */
    newTitle: string;
}

export interface RenameGroupChatRequest {
    chatId: string;
    newTitle: string;
}

export interface SendMessageToUserRequest {
    /** The unique identifier of the user to send the message to. */
    userId?: string;
    /** The text of the message, May contain links */
    text?: string | undefined;
    /** Optional attachments to include with the message. */
    attachments?: Attachment[] | undefined;
}

/** Data model for testing authorization. */
export interface TestDto {
    /** User name. */
    userName?: string | undefined;
    /** Random number */
    number?: number;
}

export interface UnauthorizedResult {
    statusCode?: number;
}

export interface UnbanUserRequest {
    serverId: string;
    userId: string;
}

export interface UnpinMessageRequest {
    /** Id of message to be unpinned */
    messageId: string;
}

export interface UpdateServerRequest {
    /** Id of the server to update */
    serverId: string;
    /** Server's name (Optional) */
    title?: string | undefined;
    /** Server's image url (Optional) */
    image?: string | undefined;
}

/** User Statuses. */
export enum UserStatus {
    Online = 0,
    Idle = 1,
    DoNotDisturb = 2,
    Offline = 3,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {ClientBase} from "./client-base";
import {ServerDetailsDto} from "../models/ServerDetailsDto";
import {Relationship} from "../models/Relationship";
import {PrivateChat} from "../models/PrivateChat";
import {Message} from "../models/Message";
import {InvitationDetails} from "../models/InvitationDetails";
import {GroupChat} from "../models/GroupChat";
import {UserDetails} from "../models/UserDetails";
import {Attachment} from "../models/Attachment";
import {EventP} from "../Events";
import ChatWebsocketService from "../ChatWebSocketService";
import {MediaDetails} from "../models/MediaDetails";

export class GetServerData extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create a text channel attached to a server
     * @param serverId Id of the server to attach the channel to
     * @param name Name of the channel to be created
     * @return Created
     */
    createChannel(serverId: string, name: string): Promise<string> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/channels?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChannel(_response);
        });
    }

    protected processCreateChannel(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : _responseText;
                return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * A request to set a new title for a provided channel
     * @param channelId Id of the channel to be renamed
     * @param name New name of the channel
     * @return Operation is successful
     */
    renameChannel(channelId: string, name: string, serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/channels/{channelId}/rename?";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{channelId}", encodeURIComponent("" + channelId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameChannel(_response);
        });
    }

    protected processRenameChannel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested channel is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * A request to remove the provided channel by it's id
     * @param channelId Id of the channel to be removed
     * @return Operation is successful
     */
    removeChannel(channelId: string, serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/channels/{channelId}/delete";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{channelId}", encodeURIComponent("" + channelId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveChannel(_response);
        });
    }

    protected processRemoveChannel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException("Bad Request. The requested channel is not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets Invitation details
     * @param id Id of the invitation to get details from
     * @return Ok. Invitation details in JSON
     */
    getInvitation(id: string): Promise<InvitationDetails> {
        let url_ = this.baseUrl + "/api/invitations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvitation(_response);
        });
    }

    protected processInvitation(response: Response): Promise<InvitationDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InvitationDetails;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("BadRequest. The invitation is expired, not available or incorrect", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvitationDetails>(null as any);
    }

    /**
     * Create an invitation as a link
     * @param serverId Id of the server to create an invitation for
     * @param body (optional) ```
     includeUser: bool // Show the user that makes this invitation
     expireTime?: Date // Define when the invitation will be expired
     ```
     * @return Success
     */
    invite(serverId: string, body: CreateInvitationRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/invitations/create";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 201) {
            return response.text();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Gets a media by it's id
     * @param url Unique id string that represents ObjectId
     * @param details (optional) <br>By default false.
     <br>If set to true, the result would be Json detailed information of the media
     <br>If set to false, the result would be media content (data in binary) showed accordingly to it's content type
     * @return <br>Ok.
     <br>By default returns the media content in binary and show it accordingly to it's content type
     <br>If the details param is set to true, returns json with the detailed information about the media
     */
    getMedia(url: string): Promise<MediaDetails> {
        let url_ = url;

        url_ += "?details=" + encodeURIComponent("" + true) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then(r => r.json());
    }

    /**
     * Uploads the media file to the database
     * @return Created. Operation is successful
     */
    uploadMedia(formData: FormData): Promise<string[]> {
        let url_ = this.baseUrl + "/api/media/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            body: formData,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadMedia(_response);
        });
    }

    protected processUploadMedia(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }

        if (status === 201) {
            return response.json();
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Returns a list of messages to show in the chat
     * @param chatId string ObjectId representation of the chat to get pinned messages from
     * @param messagesCount (optional) The amount of messages that already loaded to skip them. Set 0 to load last messages
     * @param onlyPinned (optional) If true, only pinned messages will be returned
     * @return Ok. A list of messages to show
     */
    getMessages(chatId: string, messagesCount: number, onlyPinned: boolean = false): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (messagesCount === null)
            throw new Error("The parameter 'messagesCount' cannot be null.");
        else if (messagesCount !== undefined)
            url_ += "messagesCount=" + encodeURIComponent("" + messagesCount) + "&";
        if (onlyPinned === null)
            throw new Error("The parameter 'onlyPinned' cannot be null.");
        else if (onlyPinned !== undefined)
            url_ += "onlyPinned=" + encodeURIComponent("" + onlyPinned) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<Message[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Message[];
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message[]>(null as any);
    }

    /**
     * Adds message to the given chat and notify other members about it
     * @param chatId string ObjectId representation of the chat to send message to
     * @param body (optional) ```
     text: string // Up to 2000 characters
     attachments: Attachment[] // Attachments that user includes to the message
     ```
     * @return Created. Message added
     */
    addMessage(chatId: string, body: AddMessageRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddMessage(_response);
        });
    }

    protected processAddMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds reaction to the message
     * @param messageId string ObjectId representation of the message to add reaction to
     * @param reaction (optional) Emoji code
     * @return No Content. Operation is successful
     */
    addReaction(messageId: string, reaction: string | undefined, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/reactions/add?";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (reaction === null)
            throw new Error("The parameter 'reaction' cannot be null.");
        else if (reaction !== undefined)
            url_ += "reaction=" + encodeURIComponent("" + reaction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddReaction(_response);
        });
    }

    protected processAddReaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * A request to change the given message text
     * @param body (optional) ```
     messageId: string // represents ObjectId of the message to edit
     newText: string // provided text to change the previous one
     ```
     * @return No Content. Operation is successful
     */
    editMessage(messageId: string, chatId: string, body: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditMessage(_response);
        });
    }

    protected processEditMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be the owner of the message", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Pins the selected message to the given chat
     * @param messageId string ObjectId representation of the message to pin
     * @return No Content. Operation is successful
     */
    pinMessage(messageId: string, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/pin";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPinMessage(_response);
        });
    }

    protected processPinMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove all reactions from the given message.
     * @param messageId string ObjectId representation of the message to remove reactions from
     * @return No Content. Operation is successful
     */
    removeAllReactions(messageId: string, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/reactions/remove-all";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAllReactions(_response);
        });
    }

    protected processRemoveAllReactions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove a selected attachment from the given message
     * @param messageId string ObjectId representation of the message to remove the attachment from
     * @param attachmentIndex the index of the attachment to remove
     * @return No Content. Operation is successful
     */
    removeAttachment(messageId: string, attachmentIndex: number, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/attachments?";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (attachmentIndex === undefined || attachmentIndex === null)
            throw new Error("The parameter 'attachmentIndex' must be defined and cannot be null.");
        else
            url_ += "attachmentIndex=" + encodeURIComponent("" + attachmentIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAttachment(_response);
        });
    }

    protected processRemoveAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message or attachment is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must to be the owner of the message", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes the given message with its attachments and reactions
     * @param messageId string ObjectId representation of the message to remove
     * @return No Content. Operation is successful
     */
    removeMessage(messageId: string, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveMessage(_response);
        });
    }

    protected processRemoveMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove the given reaction you have added
     * @param messageId string ObjectId representation of the message to remove the reaction from
     * @param reactionIndex the index of the reaction to remove
     * @return No Content. Operation is successful
     */
    removeReaction(messageId: string, reactionIndex: number, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/reactions/remove?";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (reactionIndex === undefined || reactionIndex === null)
            throw new Error("The parameter 'reactionIndex' must be defined and cannot be null.");
        else
            url_ += "reactionIndex=" + encodeURIComponent("" + reactionIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveReaction(_response);
        });
    }

    protected processRemoveReaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested message or reaction is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must to be the owner of the reaction", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Unpin previously pinned message
     * @param messageId string ObjectId representation of the message to unpin
     * @return No Content. Operation is successful
     */
    unpinMessage(messageId: string, chatId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chats/{chatId}/messages/{messageId}/unpin";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnpinMessage(_response);
        });
    }

    protected processUnpinMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException("Bad Request. The requested message is not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets all Private Chats the currently authorized user are member of
     * @return Ok. List of the private chat look ups
     */
    getAllPrivateChats(): Promise<PrivateChat[]> {
        let url_ = this.baseUrl + "/api/private-chats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPrivateChats(_response);
        });
    }

    protected processGetAllPrivateChats(response: Response): Promise<PrivateChat[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrivateChat[];
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivateChat[]>(null as any);
    }

    /**
     * Get details about the given group chat. The details include Title, Image, OwnerId and Users
     * @param chatId Chat Id to get detailed information from
     * @return Ok. Json group chat object
     */
    getGroupChatDetails(chatId: string): Promise<GroupChat> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupChatDetails(_response);
        });
    }

    protected processGetGroupChatDetails(response: Response): Promise<GroupChat> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GroupChat;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupChat>(null as any);
    }

    /**
     * Creates new group chat
     * @param body (optional) ```
     title: string // up to 100 characters
     image?: string // URL to the image media file
     usersId: number[] // users that are members of the chat from the beginning
     ```
     * @return Created. String representation of an ObjectId of a newly created group chat
     */
    createGroupChat(body: CreateGroupChatRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/private-chats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGroupChat(_response);
        });
    }

    protected processCreateGroupChat(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText;
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Adds the given user to the group chat as a new member
     * @param chatId Chat Id to add new member to
     * @param userId (optional) Id of the user to add
     * @return No Content. Operation is successful
     */
    addMemberToGroupChat(chatId: string, userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/add-member?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddMemberToGroupChat(_response);
        });
    }

    protected processAddMemberToGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or member is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes image of the given group chat
     * @param body (optional) ```
     chatId: string // represents ObjectId of the chat to change image
     newImage: string // URL to the image media file
     ```
     * @return No Content. Operation is successful
     */
    /**
     * Changes image of the given group chat
     * @param chatId Chat Id to change image for
     * @param body (optional) URL to the new image
     * @return No Content. Operation is successful
     */
    changeGroupChatImage(chatId: string, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/image";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeGroupChatImage(_response);
        });
    }

    protected processChangeGroupChatImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the title of the given group chat
     * @param chatId Chat Id to change title for
     * @param name (optional) New title of the group chat
     * @return No Content. Operation is successful
     */
    renameGroupChat(chatId: string, name: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/name?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameGroupChat(_response);
        });
    }

    protected processRenameGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove the currently authorized user from the group chat
     * @param chatId Chat Id to leave from
     * @param silent (optional) By default false; if true, the other chat members will not be notified
     * @return No Content. Operation is successful
     */
    leaveFromGroupChat(chatId: string, silent: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/leave?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (silent === null)
            throw new Error("The parameter 'silent' cannot be null.");
        else if (silent !== undefined)
            url_ += "silent=" + encodeURIComponent("" + silent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveFromGroupChat(_response);
        });
    }

    protected processLeaveFromGroupChat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client must be a member of the chat", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Transfer owner rights of the group chat to another member of the chat
     * @param chatId Chat Id to change owner for
     * @param newOwnerId (optional) Id of the new owner
     * @return No Content. Operation is successful
     */
    changeGroupChatOwner(chatId: string, newOwnerId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/change-owner?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        if (newOwnerId === null)
            throw new Error("The parameter 'newOwnerId' cannot be null.");
        else if (newOwnerId !== undefined)
            url_ += "newOwnerId=" + encodeURIComponent("" + newOwnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeGroupChatOwner(_response);
        });
    }

    protected processChangeGroupChatOwner(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes the given user from the chat members list
     * @param chatId Chat Id to remove member from
     * @param body (optional) ```
     memberId: int // Id of the user to remove
     silent: boolean // by default false; if true, the other chat members will not be notified
     ```
     * @return No Content. Operation is successful
     */
    removeGroupChatMember(chatId: string, body: RemoveGroupChatMemberRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/private-chats/{chatId}/kick";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined.");
        url_ = url_.replace("{chatId}", encodeURIComponent("" + chatId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveGroupChatMember(_response);
        });
    }

    protected processRemoveGroupChatMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested group chat or user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Joins to the server via invitation
     * @param invitationId Id of the invitation to join to the server
     * @return NoContent. Successful operation
     */
    joinServer(invitationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/join/{invitationId}";
        if (invitationId === undefined || invitationId === null)
            throw new Error("The parameter 'invitationId' must be defined.");
        url_ = url_.replace("{invitationId}", encodeURIComponent("" + invitationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinServer(_response);
        });
    }

    protected processJoinServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The invitation is expired, not available or incorrect", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Leave the given server
     * @param serverId Id of the server to leave from
     * @return NoContent. Successful operation
     */
    leaveServer(serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/leave";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveServer(_response);
        });
    }

    protected processLeaveServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The server is not found", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets all Servers the currently authorized user are member of
     * @return List of the server look ups
     */
    getServers(): Promise<GetServerLookupDto[]> {
        let url_ = this.baseUrl + "/api/servers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServers(_response);
        });
    }

    protected processGetServers(response: Response): Promise<GetServerLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetServerLookupDto[];
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetServerLookupDto[]>(null as any);
    }

    /**
     * Gets the detailed information about the given server
     * @param serverId string ObjectId representation of a server to get details of
     * @return Ok. Server details object in JSON
     */
    getServerDetails(serverId: string): Promise<ServerDetailsDto> {
        let url_ = this.baseUrl + "/api/servers/{serverId}";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerDetails(_response);
        });
    }

    protected processGetServerDetails(response: Response): Promise<ServerDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServerDetailsDto;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested server is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerDetailsDto>(null as any);
    }

    /**
     * Creates new server
     * @param body ```
     title: string // up to 100 characters
     image?: string // URL to the image media file
     ```
     * @return Created. String ObjectId representation of newly created Server
     */
    createServer(body: CreateServerRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/servers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServer(_response);
        });
    }

    protected processCreateServer(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Changes the given server's title or image
     * @param serverId Id of the server to update
     * @param body ```
     title?: string // up to 100 characters
     image?: string // URL to the image media file
     ```
     * @return No Content. Operation is successful
     */
    updateServer(serverId: string, body: UpdateServerRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateServer(_response);
        });
    }

    protected processUpdateServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequestResult;
                return throwException("Bad Request. The requested server is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnauthorizedResult;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ForbidResult;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes the server
     * @param serverId Id of the server to delete
     * @return No Content. Operation is successful
     */
    deleteServer(serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServer(_response);
        });
    }

    protected processDeleteServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server users list. The User can come back if would have an invitation
     * @param serverId Id of the server to kick user from
     * @param userId Id of the user to kick from the server
     * @return No Content. Operation is successful
     */
    kickUser(serverId: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/profiles/{userId}/kick";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKickUser(_response);
        });
    }

    protected processKickUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server users list and put him in a black list.
     The User can't come back even if it would have an invitation
     * @param serverId Id of the server to ban user from
     * @param userId Id of the user to ban
     * @return No Content. Operation is successful
     */
    banUser(serverId: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/profiles/{userId}/ban";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanUser(_response);
        });
    }

    protected processBanUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes User from the server's black list. Now the user could return if it would have an invitation
     * @param serverId Id of the server to unban user from
     * @param userId Id of the user to unban
     * @return No Content. Operation is successful
     */
    unbanUser(serverId: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/profiles/{userId}/unban";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnbanUser(_response);
        });
    }

    protected processUnbanUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the Display name of the server profile
     * @param serverId Id of the server to change the display name
     * @param userId Id of the user to change the display name
     * @param newName (optional) New display name
     * @return No Content. Operation is successful
     */
    changeServerProfileDisplayName(serverId: string, userId: string, newName: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/profile/{userId}/name?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (newName === null)
            throw new Error("The parameter 'newName' cannot be null.");
        else if (newName !== undefined)
            url_ += "newName=" + encodeURIComponent("" + newName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeServerProfileDisplayName(_response);
        });
    }

    protected processChangeServerProfileDisplayName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. TYour request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Changes the set of roles of the give user
     * @param serverId Id of the server to change the roles
     * @param userId Id of the user to change the roles
     * @param body (optional) New set of roles
     * @return No Content. Operation is successful
     */
    changeServerProfileRoles(serverId: string, userId: string, body: UpdateServerProfileRolesRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/servers/{serverId}/profiles/{userId}/roles";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeServerProfileRoles(_response);
        });
    }

    protected processChangeServerProfileRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. Your request is incorrect", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden. The client has not permissions to perform this action", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get information for testing authorization.
     * @return Returns the test information for authorization.
     */
    getTestDto(): Promise<TestDto> {
        let url_ = this.baseUrl + "/api/TestAuth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("The client must authenticate itself to get the requested response. The client is not authorized to access the resource.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestDto>(null as any);
    }

    /**
     * Gets detailed information about the provided user, including it's ServerProfile if ServerId is provided
     * @param userId (optional) Id of requested user. If null will return current user
     * @param serverId (optional) string ObjectId represents of server. Can be provided if ServerProfile is required. Null by default
     * @return Ok. User details object in JSON
     */
    getUser(userId?: string, serverId?: string): Promise<UserDetails> {
        let url_ = this.baseUrl + "/api/users?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (serverId === null)
            throw new Error("The parameter 'serverId' cannot be null.");
        else if (serverId !== undefined)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDetails;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetails>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    sendMessageToUser(body: SendMessageToUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessageToUser(_response);
        });
    }

    protected processSendMessageToUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets all relationships of the current user
     * @return Ok. List of current user relationships in JSON
     */
    getRelationships(): Promise<Relationship[]> {
        let url_ = this.baseUrl + "/api/users/relationships";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain",
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelationships(_response);
        });
    }

    protected processGetRelationships(response: Response): Promise<Relationship[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Relationship[];
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Relationship[]>(null as any);
    }

    /**
     * Sends a friend request to the user with the provided id
     * @param userId (optional) Id of the user to send a friend request to
     * @return No Content. The request was sent successfully
     */
    sendFriendRequest(userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users/add-friend?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendFriendRequest(_response);
        });
    }

    protected processSendFriendRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Accepts a friend request from the user with the provided id
     * @param userId (optional) Id of the user to accept a friend request from
     * @return No Content. The request was accepted successfully
     */
    acceptFriendRequest(userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users/accept-friend?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptFriendRequest(_response);
        });
    }

    protected processAcceptFriendRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        }
        ;
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets userId from its user name string. Useful for friend requests
     * @param userName (optional) The user name string to find user by
     * @return Ok. User's GUID
     */
    getUserByUserName(userName: string): Promise<string> {
        let url_ = this.baseUrl + "/api/users/user-by-username?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "Get",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token")
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserByUserName(_response);
        });
    }

    protected processGetUserByUserName(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text();
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request. The requested user is not found", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Unauthorized. The client must be authorized to send this request", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}


export interface AddMessageRequest {
    /** Text of the message. Can include links */
    text?: string | undefined;
    /** Id of the chat to send message to */
    attachments?: Attachment[] | undefined;
}

export interface AuthenticationProperties {
    items?: { [key: string]: string; } | undefined;
}

export interface BadRequestResult {
    statusCode?: number;
}

/** Request for updating server profile roles */
export interface UpdateServerProfileRolesRequest {
    /** List of roles to be assigned to the user */
    roles?: string[] | undefined;
}

export interface CreateGroupChatRequest {
    /** The title of the group chat. */
    title: string | undefined;
    /** The URL of the image for the group chat. (Optional) */
    image?: string | undefined;
    /** The list of unique identifiers of users to be added to the group chat. */
    usersId: string[];
}

export interface CreateInvitationRequest {
    /** Indicates whether to include user information in the invitation. */
    includeUser?: boolean;
    /** The expiration time of the invitation. (Optional) */
    expireTime?: Date | undefined;
}

export interface CreateServerRequest {
    /** New Server's name */
    title: string;
    /** Server image url */
    image?: string | undefined;
}

export interface ForbidResult {
    authenticationSchemes?: string[] | undefined;
    properties?: AuthenticationProperties;
}

export interface GetServerLookupDto {
    /** The unique identifier of the server */
    id?: string | undefined;
    /** Server's name */
    title?: string | undefined;
    /** Avatar Url of the Server */
    image?: string | undefined;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum RelationshipType {
    Acquaintance = 0,
    Friend = 1,
    Pending = 2,
    Waiting = 3,
    Blocked = 4,
}


export interface RemoveGroupChatMemberRequest {
    /** The unique identifier of the member to be removed from the group chat. */
    memberId: string;
    /** Indicates whether to remove the member silently without sending notifications. (Optional, default is false) */
    silent?: boolean;
}

export interface SendMessageToUserRequest {
    /** The unique identifier of the user to send the message to. */
    userId?: string;
    /** The text of the message, May contain links */
    text?: string | undefined;
    /** Optional attachments to include with the message. */
    attachments?: Attachment[] | undefined;
}

/** Data model for testing authorization. */
export interface TestDto {
    /** User name. */
    userName?: string | undefined;
    /** Random number */
    number?: number;
}

export interface UnauthorizedResult {
    statusCode?: number;
}

export interface UpdateServerRequest {
    /** Server's name (Optional) */
    title?: string | undefined;
    /** Server's image url (Optional) */
    image?: string | undefined;
}

/** User Statuses. */
export enum UserStatus {
    Online = 0,
    Idle = 1,
    DoNotDisturb = 2,
    Offline = 3,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}